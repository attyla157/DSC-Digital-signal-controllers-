/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 ******************************************************************************
 ******************************************************************************
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32l4xx.h>
#include <stm32l4xx_ll_bus.h>
#include <stm32l4xx_ll_gpio.h>
#include <stm32l4xx_ll_utils.h>
#include <stm32l4xx_ll_usart.h>
#include <stdbool.h>


/*
 *
 *
 * PA2 - af7 oraz PA15 af3 do USART
 * alternative functions for pins
 */
int soft_counter = 0;
char text_to_send[]="Inhale...\r\n";
char recived_text;
char recived_time_value[5];
int character_input_counter = 0;
int time_value = 0;
bool time_elapsed = true;
int main(void)
{
	LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);
	LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOA);

	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);
	SystemCoreClockUpdate();
	LL_Init1msTick(SystemCoreClock);

	//SysTick_Config(SystemCoreClock); // przerwanie systicka co sekunde

	NVIC_EnableIRQ(USART2_IRQn);
	LL_USART_EnableIT_RXNE(USART2);

	//nvic interrupt enable
	//enable usart interrupt
	//odbierz znak i cos tam

	LL_GPIO_InitTypeDef gpio_s;

	LL_GPIO_StructInit(&gpio_s); // default inicialization of structure

	//inicialization of corect parameters
	gpio_s.Mode = LL_GPIO_MODE_OUTPUT;
	gpio_s.Pin = LL_GPIO_PIN_3;

	////////////////////////////////
	//uart config pins

	LL_GPIO_InitTypeDef gpio_uart_2;
		LL_GPIO_StructInit(&gpio_uart_2);
		gpio_uart_2.Mode = LL_GPIO_MODE_ALTERNATE;
		gpio_uart_2.Pin = LL_GPIO_PIN_2;
		gpio_uart_2.Alternate = LL_GPIO_AF_7;

	LL_GPIO_InitTypeDef gpio_uart_15;
		LL_GPIO_StructInit(&gpio_uart_15);
		gpio_uart_15.Mode = LL_GPIO_MODE_ALTERNATE;
		gpio_uart_15.Pin = LL_GPIO_PIN_15;
		gpio_uart_15.Alternate = LL_GPIO_AF_3;

	LL_GPIO_Init(GPIOA, &gpio_uart_15);
	LL_GPIO_Init(GPIOA, &gpio_uart_2);
	LL_GPIO_Init(GPIOB, &gpio_s);


	////////////
	//usart config



	LL_USART_InitTypeDef usart2_param;
		LL_USART_StructInit(&usart2_param);
		LL_USART_Init(USART2, &usart2_param);

		LL_USART_Enable(USART2);
		LL_USART_TransmitData8(USART2, 'a');

		send_text(&text_to_send, sizeof(text_to_send));
    /* Loop forever */
	while(1)
	{
	//LL_mDelay(500);
	 //LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);
	 //LL_USART_TransmitData8(USART2, 'a');

	 //LL_USART_IsActiveFlag_TXE(USART2);
	 //send_text(&text_to_send, sizeof(text_to_send));
	 if(time_elapsed == false)
	 {
		 LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_3);
		 LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_3);
	 	 LL_mDelay(time_value);
		 LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_3);
		 time_elapsed = true;
	 }




	}
}



void SysTick_Handler(void)
{
	soft_counter++;
	//LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);
}
void USART2_IRQHandler (void)
{
	recived_text = LL_USART_ReceiveData8(USART2);
	recived_time_value[character_input_counter]=recived_text;
	//LL_USART_TransmitData8(USART2, recived_text);
	if (recived_text == 'd')
	{
		LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);
		send_text("zmiana stanu Diody\r\n", sizeof("zmiana stanu Diody\r\n"));
	}
	if (recived_text == 13 )
	{
		send_text("\r\n", sizeof("\r\n"));
		send_text(&recived_time_value, sizeof(recived_time_value));

		sscanf(recived_time_value,"%d",&time_value);
		//time_value = atoi(recived_time_value);
		time_elapsed = false;
		for(int i=0;i<5;i++)
		{
			recived_time_value[i] = 0;
		}
		send_text("\r\n", sizeof("\r\n"));
		character_input_counter = 0;
	}


		character_input_counter++;
	if(character_input_counter > (sizeof(recived_time_value) / sizeof(char)))
	{
		character_input_counter=0;
	}
}

void send_text( char *data, int size)
{
	int count  = size/sizeof(char);

	for (int i=0;i<count;i++)
	{
		while(!LL_USART_IsActiveFlag_TXE(USART2));
		LL_USART_TransmitData8(USART2, data[i]);

	}

}
