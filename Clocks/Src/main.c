/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 ******************************************************************************
 ******************************************************************************
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32l4xx.h>
#include <stm32l4xx_ll_bus.h>
#include <stm32l4xx_ll_gpio.h>
#include <stm32l4xx_ll_utils.h>
#include <stm32l4xx_ll_usart.h>
#include <stdbool.h>


/*
 *
 *
 * PA2 - af7 oraz PA15 af3 do USART
 * alternative functions for pins
 */
int soft_counter = 0;
char text_to_send[]="Inhale...\r\n";
char recived_text;
char recived_time_value[5];
int character_input_counter = 0;
int time_value = 0;
int clock_mode = -1;
int prescaler_mode = -1;
int sys_clock_mux_mode = -1;
int temp;
bool time_elapsed = true;

#define bdcr (0x2000000u)
#define msi_sel (0x2000000u)
#define sysclk_sel (0x1000000u)
#define hsi_sel (0x3000000u)
#define hse_sel (0x4000000u)
#define lsi_sel (0x6000000u)
#define lse_sel (0x7000000u)
#define clear_sel (0xF000000u)
#define pll_sel (0x5000000u)
#define PLL_DIV_31 (0xF8000000u)
#define PLL_PLLR  (0x2000000u)
#define PLL_PLLREN (0x1000000u)
#define PLL_PLLQ (0x600000u)
#define PLL_PLLN (0x5000u)
#define PLL_PLLM (0x30u)
#define PLL_SRC_HSI (0x2u)

LL_USART_InitTypeDef usart2_param;
int main(void)
{
	//aktualizuj konfiguracje usarta przy zmianie czestotliwosic zegaray

	//197/1600
	LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);
	LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOA);

	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);

	SystemCoreClockUpdate();
	LL_Init1msTick(SystemCoreClock);

	//SysTick_Config(SystemCoreClock); // przerwanie systicka co sekunde

	NVIC_EnableIRQ(USART2_IRQn);
	LL_USART_EnableIT_RXNE(USART2);

	//nvic interrupt enable
	//enable usart interrupt
	//odbierz znak i cos tam

	LL_GPIO_InitTypeDef gpio_s;

	LL_GPIO_StructInit(&gpio_s); // default inicialization of structure

	//inicialization of corect parameters
	gpio_s.Mode = LL_GPIO_MODE_OUTPUT;
	gpio_s.Pin = LL_GPIO_PIN_3;

	////////////////////////////////
	//uart config pins

	LL_GPIO_InitTypeDef gpio_mco_8; // generacja sygnalu
			LL_GPIO_StructInit(&gpio_mco_8);
			gpio_mco_8.Mode = LL_GPIO_MODE_ALTERNATE;
			gpio_mco_8.Pin = LL_GPIO_PIN_8;
			gpio_mco_8.Alternate = LL_GPIO_AF_0;
			gpio_mco_8.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;

	LL_GPIO_InitTypeDef gpio_uart_2;
		LL_GPIO_StructInit(&gpio_uart_2);
		gpio_uart_2.Mode = LL_GPIO_MODE_ALTERNATE;
		gpio_uart_2.Pin = LL_GPIO_PIN_2;
		gpio_uart_2.Alternate = LL_GPIO_AF_7;

	LL_GPIO_InitTypeDef gpio_uart_15;
		LL_GPIO_StructInit(&gpio_uart_15);
		gpio_uart_15.Mode = LL_GPIO_MODE_ALTERNATE;
		gpio_uart_15.Pin = LL_GPIO_PIN_15;
		gpio_uart_15.Alternate = LL_GPIO_AF_3;

	LL_GPIO_Init(GPIOA, &gpio_mco_8);
	LL_GPIO_Init(GPIOA, &gpio_uart_15);
	LL_GPIO_Init(GPIOA, &gpio_uart_2);
	LL_GPIO_Init(GPIOB, &gpio_s);

	//power cos tam
	RCC -> APB1ENR1 |= RCC_APB1ENR1_PWREN;
	PWR -> CR1 |= PWR_CR1_DBP;
	//RCC -> BDCR |=RCC_BDCR_RTCEN;
	//RCC -> BDCR |= RCC_BDCR_RTCSEL_0;
	//RCC -> BDCR |= RCC_BDCR_RTCSEL_1;

	RCC -> CFGR |= RCC_CFGR_MCOSEL_1; //clock output selector
	//RCC -> BDCR |= RCC_BDCR_LSI

	RCC -> CR |= RCC_CR_HSION;// włącza HSI
	RCC -> CR |= RCC_CR_HSEON;
	RCC -> CR |= RCC_CR_MSION;

	//petla pll

	//RCC ->PLLCFGR |= PLL_DIV_31;
	RCC ->PLLCFGR |= PLL_PLLR;
	RCC ->PLLCFGR |= PLL_PLLREN;
	RCC ->PLLCFGR |= PLL_PLLN;
	RCC ->PLLCFGR |= PLL_PLLM;
	RCC ->PLLCFGR &= ~RCC_PLLCFGR_PLLSRC;
	RCC ->PLLCFGR |= PLL_SRC_HSI;
	RCC ->PLLCFGR |= PLL_PLLQ;

	RCC -> CR |= RCC_CR_PLLON;// włącza pętle pll
	////////////

	///lse
	RCC ->BDCR |= bdcr;
	RCC ->BDCR |= RCC_BDCR_LSEON;
	//usart config




		LL_USART_StructInit(&usart2_param);
		LL_USART_Init(USART2, &usart2_param);

		LL_USART_Enable(USART2);
		LL_USART_TransmitData8(USART2, 'a');

		send_text(&text_to_send, sizeof(text_to_send));
    /* Loop forever */
	while(1)
	{
	//LL_mDelay(500);
	 //LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);
	 //LL_USART_TransmitData8(USART2, 'a');

	 //LL_USART_IsActiveFlag_TXE(USART2);
	 //send_text(&text_to_send, sizeof(text_to_send));
		//LL_USART_StructInit(&usart2_param);
		//LL_USART_Init(USART2, &usart2_param);
	 if(time_elapsed == false)
	 {
		 LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_3);
		 LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_3);
	 	 LL_mDelay(time_value);
		 LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_3);
		 time_elapsed = true;
	 }




	}
}



void SysTick_Handler(void)
{
	soft_counter++;
	//LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);
}
void USART2_IRQHandler (void)
{
	recived_text = LL_USART_ReceiveData8(USART2);
	recived_time_value[character_input_counter]=recived_text;
	//LL_USART_TransmitData8(USART2, recived_text);
	if (recived_text == 's')
	{
		LL_GPIO_TogglePin(GPIOB, LL_GPIO_PIN_3);
		send_text("zmiana wyjscia MCO\r\n", sizeof("zmiana wyjscia MCO\r\n"));
		clock_mode++;
		if(clock_mode == 0) //sel
		{	CLEAR_BIT(RCC -> CFGR, clear_sel);
			RCC -> CFGR |= lse_sel ;
			send_text("LSE\r\n", sizeof("LSE\r\n"));
		}
		else if (clock_mode == 1)
		{
			CLEAR_BIT(RCC -> CFGR, clear_sel);
			RCC -> CFGR |= msi_sel;
			send_text("MSI\r\n", sizeof("MSI\r\n"));
		}
		else if(clock_mode == 2)
		{
			CLEAR_BIT(RCC -> CFGR, clear_sel);
			RCC -> CFGR |= sysclk_sel;
			send_text("SYSCLK\r\n", sizeof("SYSCLK\r\n"));
		}
		else if(clock_mode == 3)
		{
			CLEAR_BIT(RCC -> CFGR, clear_sel);
			RCC -> CFGR |= hsi_sel;
			send_text("HSI\r\n", sizeof("HSI\r\n"));
		}
		else if (clock_mode == 4)
		{
			CLEAR_BIT(RCC -> CFGR, clear_sel);
			RCC -> CFGR |= pll_sel;
			send_text("PLL\r\n", sizeof("PLL\r\n"));
		}
		else
		{
			clock_mode = -1;
		}
	}

	if (recived_text == 'p') //pre
	{
		send_text("Zmiana Prescalera \r\n", sizeof("Zmiana Prescalera \r\n"));
		prescaler_mode++;
		if(prescaler_mode == 0)
		{

			CLEAR_BIT(RCC -> CFGR,RCC_CFGR_MCOPRE_Msk);// CLEAR PRESCALER
			RCC -> CFGR |= RCC_CFGR_MCOPRE_DIV1;
			send_text("DIV1\r\n", sizeof("DIV1\r\n"));

		}
		else if (prescaler_mode == 1)
		{	temp = RCC->CFGR;


			CLEAR_BIT(RCC -> CFGR,RCC_CFGR_MCOPRE_Msk);// CLEAR PRESCALER
			RCC -> CFGR |= RCC_CFGR_MCOPRE_DIV2;
			send_text("DIV2\r\n", sizeof("DIV2\r\n"));

		}
		else if(prescaler_mode == 2)
		{

			CLEAR_BIT(RCC -> CFGR,RCC_CFGR_MCOPRE_Msk);// CLEAR PRESCALER
			RCC -> CFGR |=RCC_CFGR_MCOPRE_DIV4;
			send_text("DIV4\r\n", sizeof("DIV4\r\n"));
		}
		else if(prescaler_mode == 3)
		{

					CLEAR_BIT(RCC -> CFGR,RCC_CFGR_MCOPRE_Msk);// CLEAR PRESCALER
					RCC -> CFGR |=RCC_CFGR_MCOPRE_DIV8;
					send_text("DIV8\r\n", sizeof("DIV8\r\n"));
		}
		else if(prescaler_mode == 4)
		{


					CLEAR_BIT(RCC -> CFGR,RCC_CFGR_MCOPRE_Msk);// CLEAR PRESCALER
					RCC -> CFGR |=RCC_CFGR_MCOPRE_DIV16;
					send_text("DIV16\r\n", sizeof("DIV16\r\n"));

		}

		else
		{
			prescaler_mode = -1;
		}
	}
		if (recived_text == 'c')
		{


			send_text("Zmiana SYSCLK MUX \r\n", sizeof("Zmiana SYSCLK MUX \r\n"));
				sys_clock_mux_mode++;
				if(sys_clock_mux_mode == 0)
				{ 	send_text("Zmiana SYSCLK MUX  na MSI\r\n", sizeof("Zmiana SYSCLK MUX  na MSI\r\n"));
					CLEAR_BIT(RCC -> CFGR,RCC_CFGR_SW_Msk);
					RCC -> CFGR |= RCC_CFGR_SW_MSI ;
				}
				else if (sys_clock_mux_mode == 1)
				{
					send_text("Zmiana SYSCLK MUX  na HSI\r\n", sizeof("Zmiana SYSCLK MUX  na HSI\r\n"));
					CLEAR_BIT(RCC -> CFGR,RCC_CFGR_SW_Msk);
					RCC -> CFGR |= RCC_CFGR_SW_HSI ;
				}
				else if (sys_clock_mux_mode == 2)
				{
					send_text("Zmiana SYSCLK MUX  na HSE\r\n", sizeof("Zmiana SYSCLK MUX  na HSE\r\n"));
					CLEAR_BIT(RCC -> CFGR,RCC_CFGR_SW_Msk);
					RCC -> CFGR |= RCC_CFGR_SW_HSE ;
				}
				else if (sys_clock_mux_mode == 3)
				{
					send_text("Zmiana SYSCLK MUX  na PLL\r\n", sizeof("Zmiana SYSCLK MUX  na PLL\r\n"));
					CLEAR_BIT(RCC -> CFGR,RCC_CFGR_SW_Msk);
					RCC -> CFGR |= RCC_CFGR_SW_PLL ;
				}
				else
				{

					sys_clock_mux_mode = -1;
				}






	}
		LL_USART_Disable(USART2);
		LL_USART_StructInit(&usart2_param);
		LL_USART_Init(USART2, &usart2_param);
		LL_USART_Enable(USART2);
}

void send_text( char *data, int size)
{
	int count  = size/sizeof(char);

	for (int i=0;i<count;i++)
	{
		while(!LL_USART_IsActiveFlag_TXE(USART2));
		LL_USART_TransmitData8(USART2, data[i]);

	}

}
